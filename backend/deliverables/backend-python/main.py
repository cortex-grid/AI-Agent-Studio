"""
Standalone MAF Backend - Graph-aware agent system with tools and orchestration.
Generated by Agent Canvas - Ready to deploy!
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import Optional, Dict, Any, AsyncIterator, List
import json
import os
from pathlib import Path
from dotenv import load_dotenv

# Local imports
from tool_factory import ToolFactory
from agent_factory import AgentFactory
from graph_builder import GraphBuilder

load_dotenv()

app = FastAPI(title="MAF Agent Backend", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global state
project_config = None
agents = {}
root_agent_ids = []
tool_factory = ToolFactory()
agent_factory = AgentFactory()


class ChatRequest(BaseModel):
    message: str
    target: str = "team"
    thread_id: Optional[str] = None


def load_project_config():
    """Load project.json from parent directory."""
    project_file = Path(__file__).parent.parent / "project.json"
    if not project_file.exists():
        raise FileNotFoundError("project.json not found")
    with open(project_file, 'r', encoding='utf-8') as f:
        return json.load(f)


async def build_agents():
    """
    Build all agents from project configuration with graph-aware tool mapping.
    
    Architecture:
    1. Parse edges to find tool→agent and agent→manager relationships
    2. Instantiate tools using ToolFactory
    3. Create agents with their tools using AgentFactory
    4. Build orchestrated managers with child agents
    """
    global agents, root_agent_ids
    
    graph = project_config.get("graph", {})
    nodes_list = graph.get("nodes", [])
    edges = graph.get("edges", [])
    
    # Build graph structure
    graph_builder = GraphBuilder(nodes_list, edges)
    
    # Validate graph
    warnings = graph_builder.validate_graph()
    for warning in warnings:
        print(f"⚠ {warning}")
    
    # Build mappings
    agent_tool_map = graph_builder.build_agent_tool_map()
    orchestration_tree = graph_builder.build_orchestration_tree()
    
    # Index nodes
    nodes = {n["id"]: n for n in nodes_list}
    
    # Step 1: Instantiate all tools
    tool_instances = {}
    for node_id, node in nodes.items():
        if node.get("type") == "tool":
            try:
                tool = tool_factory.create_tool(node)
                if tool:
                    tool_instances[node_id] = tool
                    tool_label = node.get("data", {}).get("label", node_id)
                    print(f"✓ Created tool: {tool_label}")
                else:
                    print(f"⚠ Tool {node_id} returned None (not implemented)")
            except Exception as e:
                print(f"✗ Failed to create tool {node_id}: {e}")
    
    # Step 2: Create standalone agents (not team managers, not children of managers)
    standalone_agents = {}
    for node_id, node in nodes.items():
        if (node.get("type") == "agent" and 
            not graph_builder.is_manager(node_id) and 
            node_id not in orchestration_tree):
            
            # Get tools for this agent
            tool_ids = agent_tool_map.get(node_id, [])
            agent_tools = [tool_instances[tid] for tid in tool_ids if tid in tool_instances]
            
            try:
                agent = agent_factory.create_agent(node, tools=agent_tools)
                standalone_agents[node_id] = agent
                agents[node_id] = agent
                agent_label = node.get("data", {}).get("label", node_id)
                print(f"✓ Created agent: {agent_label} (with {len(agent_tools)} tools)")
            except Exception as e:
                print(f"✗ Failed to create agent {node_id}: {e}")
    
    # Step 3: Create child agents for managers
    child_agents_map = {}
    for manager_id in orchestration_tree.keys():
        child_ids = orchestration_tree[manager_id]
        child_agents_map[manager_id] = []
        
        for child_id in child_ids:
            if child_id in standalone_agents:
                # Already created as standalone
                child_agents_map[manager_id].append(standalone_agents[child_id])
                continue
            
            child_node = nodes.get(child_id)
            if not child_node:
                print(f"✗ Child agent {child_id} not found in nodes")
                continue
            
            # Get tools for child agent
            tool_ids = agent_tool_map.get(child_id, [])
            agent_tools = [tool_instances[tid] for tid in tool_ids if tid in tool_instances]
            
            try:
                agent = agent_factory.create_agent(child_node, tools=agent_tools)
                child_agents_map[manager_id].append(agent)
                agents[child_id] = agent  # Store for reference
                agent_label = child_node.get("data", {}).get("label", child_id)
                print(f"✓ Created child agent: {agent_label} (with {len(agent_tools)} tools)")
            except Exception as e:
                print(f"✗ Failed to create child agent {child_id}: {e}")
    
    # Step 4: Create orchestrated team managers
    for manager_id in orchestration_tree.keys():
        manager_node = nodes.get(manager_id)
        if not manager_node:
            continue
        
        child_agents = child_agents_map.get(manager_id, [])
        if not child_agents:
            print(f"⚠ Manager {manager_id} has no valid child agents")
            continue
        
        try:
            orchestrated_agent = agent_factory.create_orchestrated_agent(
                manager_node,
                child_agents
            )
            agents[manager_id] = orchestrated_agent
            manager_label = manager_node.get("data", {}).get("label", manager_id)
            strategy = graph_builder.get_orchestration_strategy(manager_id)
            print(f"✓ Created team manager: {manager_label} (strategy: {strategy}, {len(child_agents)} agents)")
        except Exception as e:
            print(f"✗ Failed to create manager {manager_id}: {e}")
    
    # Determine root agents (agents to expose in API)
    root_agent_ids = graph_builder.get_root_agents()
    
    print(f"\n✓ Total agents created: {len(agents)}")
    print(f"✓ Root agents: {len(root_agent_ids)}")
    print(f"✓ Tools instantiated: {len(tool_instances)}")


@app.on_event("startup")
async def startup_event():
    """Initialize on startup."""
    global project_config
    project_config = load_project_config()
    await build_agents()
    
    print(f"✓ Loaded project: {project_config.get('name', 'Unknown')}")
    print(f"✓ Provider: {os.getenv('PROVIDER', 'openai')}")
    print(f"✓ Agents: {len(agents)}")


@app.get("/")
async def root():
    """Root endpoint."""
    if not project_config:
        return {"error": "Project not loaded"}
    
    return {
        "name": project_config.get("name", "MAF Agent"),
        "version": "1.0.0",
        "agents": len(agents),
        "root_agents": len(root_agent_ids)
    }


@app.get("/api/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "provider": os.getenv("PROVIDER", "openai"),
        "agents": list(agents.keys()),
        "root_agents": root_agent_ids
    }


@app.get("/api/agents")
async def list_agents():
    """List all available agents with their root status."""
    if not project_config:
        return {"agents": []}
    
    agent_list = []
    graph = project_config.get("graph", {})
    nodes = graph.get("nodes", [])
    
    for node in nodes:
        if node.get("type") == "agent":
            node_id = node.get("id")
            data = node.get("data", {})
            kind = data.get("kind")
            is_manager = kind in {"teamManager", "teamDirector"}
            is_director = kind == "teamDirector"
            is_root = node_id in root_agent_ids
            
            agent_list.append({
                "id": node_id,
                "name": data.get("label", node_id),
                "system": data.get("system", ""),
                "model": data.get("model", ""),
                "is_manager": is_manager,
                "is_director": is_director,
                "is_root": is_root,
                "available": node_id in agents
            })
    
    return {
        "agents": agent_list,
        "total": len(agent_list),
        "available": len(agents)
    }


async def stream_agent_response(agent, message: str) -> AsyncIterator[Dict[str, Any]]:
    """Stream agent response as JSON events."""
    try:
        async for update in agent.run_stream(message):
            if hasattr(update, "delta") and update.delta:
                yield {"type": "text", "data": {"delta": str(update.delta)}}
            elif hasattr(update, "tool_calls") and update.tool_calls:
                for tool_call in update.tool_calls:
                    yield {
                        "type": "tool_call",
                        "data": {
                            "name": getattr(tool_call, "name", "unknown"),
                            "args": getattr(tool_call, "arguments", {}),
                        }
                    }
            else:
                yield {"type": "text", "data": {"delta": str(update)}}
    except Exception as e:
        yield {"type": "error", "data": {"message": str(e)}}


@app.post("/api/chat/stream")
async def chat_stream(request: ChatRequest):
    """
    Streaming chat endpoint.
    Returns line-delimited JSON events.
    
    Supports:
    - target="team": Uses first root agent (typically a team manager)
    - target=<agent_id>: Uses specific agent by ID
    """
    target = request.target
    
    # Find target agent
    agent = None
    if target == "team":
        # Use first root agent (prioritize managers)
        if root_agent_ids:
            agent = agents.get(root_agent_ids[0])
        elif agents:
            # Fallback to any available agent
            agent = list(agents.values())[0]
    elif target in agents:
        agent = agents[target]
    
    if not agent:
        raise HTTPException(
            status_code=404, 
            detail=f"Agent '{target}' not found. Available: {list(agents.keys())}"
        )
    
    async def event_generator():
        yield json.dumps({"type": "notice", "data": {"message": "Starting..."}}) + "\n"
        async for event in stream_agent_response(agent, request.message):
            yield json.dumps(event) + "\n"
        yield json.dumps({"type": "notice", "data": {"message": "Complete"}}) + "\n"
    
    return StreamingResponse(
        event_generator(),
        media_type="application/x-ndjson"
    )


@app.post("/api/chat")
async def chat(request: ChatRequest):
    """
    Non-streaming chat endpoint.
    
    Supports:
    - target="team": Uses first root agent (typically a team manager)
    - target=<agent_id>: Uses specific agent by ID
    """
    target = request.target
    
    agent = None
    agent_id = None
    
    if target == "team":
        if root_agent_ids:
            agent_id = root_agent_ids[0]
            agent = agents.get(agent_id)
        elif agents:
            agent_id = list(agents.keys())[0]
            agent = agents[agent_id]
    elif target in agents:
        agent_id = target
        agent = agents[target]
    
    if not agent:
        raise HTTPException(
            status_code=404, 
            detail=f"Agent '{target}' not found. Available: {list(agents.keys())}"
        )
    
    # Collect full response
    text_parts = []
    async for event in stream_agent_response(agent, request.message):
        if event.get("type") == "text":
            text_parts.append(event["data"]["delta"])
    
    return {
        "response": "".join(text_parts),
        "thread_id": request.thread_id or "new-thread",
        "agent_used": agent_id or target
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
